<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>K2 - Remove Row</title>
  <style>
    body { font-family: system-ui; padding: 1rem; background: #0f0f0f; color: #e0e0e0; }
    button { padding: 0.5rem 1rem; margin: 0.25rem; cursor: pointer; }
    .row { padding: 0.25rem 0.5rem; border-bottom: 1px solid #333; display: flex; justify-content: space-between; }
    .row button { padding: 0.1rem 0.5rem; font-size: 0.8rem; }
    #results { margin: 1rem 0; padding: 1rem; background: #1a1a1a; border-radius: 4px; }
    #container { max-height: 400px; overflow-y: auto; }
  </style>
</head>
<body>
  <h1>K2 - Remove Row Benchmark (x-for)</h1>

  <div id="controls">
    <button onclick="runBenchmark()">Run Benchmark (5 iterations)</button>
    <button onclick="createRows()">Create 1000 Rows</button>
  </div>

  <div id="results">
    <div>Last remove: <span id="lastRun">-</span></div>
    <div>Average: <span id="average">-</span></div>
  </div>

  <div id="container"></div>

  <script src="../../dist/k2.min.js"></script>
  <script>
    const { State, effect } = K2;

    const rows = new State([]);
    let nextId = 1;

    const container = document.getElementById('container');
    const lastRunEl = document.getElementById('lastRun');
    const averageEl = document.getElementById('average');

    // Key -> DOM element mapping for efficient updates
    const keyMap = new Map();
    let currentKeys = [];

    function removeRow(id) {
      rows.set(rows.get().filter(r => r.id !== id));
    }

    // Keyed reconciliation effect
    effect(() => {
      const currentRows = rows.get();
      const newKeys = currentRows.map(r => r.id);
      const newKeySet = new Set(newKeys);

      // Phase 1: Remove items not in new array
      for (const oldKey of currentKeys) {
        if (!newKeySet.has(oldKey)) {
          const el = keyMap.get(oldKey);
          if (el) {
            el.remove();
            keyMap.delete(oldKey);
          }
        }
      }

      // Phase 2: Add new items, reorder existing
      let prevNode = null;
      for (let i = 0; i < currentRows.length; i++) {
        const row = currentRows[i];
        const key = row.id;
        let el = keyMap.get(key);

        if (!el) {
          // Create new element
          el = document.createElement('div');
          el.className = 'row';
          el.innerHTML = `<span>${row.label}</span><button>X</button>`;
          el.querySelector('button').onclick = () => removeRow(row.id);
          keyMap.set(key, el);
        }

        // Position correctly
        if (prevNode) {
          if (el.previousSibling !== prevNode) {
            prevNode.after(el);
          }
        } else {
          if (el !== container.firstChild) {
            container.prepend(el);
          }
        }
        prevNode = el;
      }

      currentKeys = newKeys;
    });

    function buildData(count) {
      const adjectives = ['pretty', 'large', 'big', 'small', 'tall', 'short', 'long', 'handsome', 'plain', 'quaint'];
      const colours = ['red', 'yellow', 'blue', 'green', 'pink', 'brown', 'purple', 'white', 'black', 'orange'];
      const nouns = ['table', 'chair', 'house', 'bbq', 'desk', 'car', 'pony', 'cookie', 'sandwich', 'burger'];
      const data = [];
      for (let i = 0; i < count; i++) {
        data.push({
          id: nextId++,
          label: adjectives[Math.floor(Math.random() * adjectives.length)] + ' ' +
                 colours[Math.floor(Math.random() * colours.length)] + ' ' +
                 nouns[Math.floor(Math.random() * nouns.length)]
        });
      }
      return data;
    }

    function createRows() {
      rows.set(buildData(1000));
    }

    const times = [];
    async function runBenchmark() {
      times.length = 0;

      for (let i = 0; i < 5; i++) {
        createRows();
        await new Promise(r => setTimeout(r, 100));

        const currentRows = rows.get();
        const randomIndex = Math.floor(Math.random() * currentRows.length);
        const id = currentRows[randomIndex].id;

        const start = performance.now();
        rows.set(currentRows.filter(r => r.id !== id));
        await new Promise(r => requestAnimationFrame(r));
        const end = performance.now();

        const time = end - start;
        times.push(time);
        lastRunEl.textContent = `${time.toFixed(2)}ms`;
        await new Promise(r => setTimeout(r, 100));
      }

      const avg = times.reduce((a, b) => a + b, 0) / times.length;
      averageEl.textContent = `${avg.toFixed(2)}ms (${times.map(t => t.toFixed(1)).join(', ')})`;

      if (window.parent !== window) {
        window.parent.postMessage({
          type: 'benchmark-result',
          framework: 'k2',
          benchmark: 'remove',
          time: avg
        }, '*');
      }
    }

    if (new URLSearchParams(window.location.search).get('autorun') === 'true') {
      setTimeout(runBenchmark, 100);
    }
  </script>
</body>
</html>
