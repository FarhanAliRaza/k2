{
  "version": 3,
  "sources": ["../src/index.ts", "../src/signals.ts", "../src/effect.ts"],
  "sourcesContent": ["/**\n * SignalHTML - An Alpine.js-like framework powered by TC39 Signals\n *\n * Usage:\n * <div x-data=\"{ count: 0 }\">\n *   <span x-text=\"count\"></span>\n *   <button @click=\"count++\">+</button>\n * </div>\n */\n\nimport { State, Computed, untrack } from './signals';\nimport { effect } from './effect';\n\nexport { State, Computed, untrack } from './signals';\nexport { effect } from './effect';\n\ntype SignalStore = Record<string, State<unknown>>;\ntype ComputedStore = Record<string, Computed<unknown>>;\n\ninterface ComponentScope {\n  signals: SignalStore;\n  computeds: ComputedStore;\n  el: Element;\n  get: (key: string) => unknown;\n  set: (key: string, value: unknown) => void;\n}\n\nconst DIRECTIVES = {\n  DATA: 'x-data',\n  TEXT: 'x-text',\n  HTML: 'x-html',\n  SHOW: 'x-show',\n  BIND: 'x-bind',\n  MODEL: 'x-model',\n  ON: 'x-on',\n  IF: 'x-if',\n  FOR: 'x-for',\n  REF: 'x-ref',\n} as const;\n\n// Store active scopes\nconst scopes = new WeakMap<Element, ComponentScope>();\n\nfunction createScopeFromString(el: Element, dataStr: string): ComponentScope {\n  const signals: SignalStore = {};\n  const computeds: ComputedStore = {};\n\n  // Create scope object first\n  const scope: ComponentScope = {\n    signals,\n    computeds,\n    el,\n    get(key: string): unknown {\n      if (key in signals) {\n        return signals[key].get();\n      }\n      if (key in computeds) {\n        return computeds[key].get();\n      }\n      return undefined;\n    },\n    set(key: string, value: unknown): void {\n      if (key in signals) {\n        signals[key].set(value);\n      }\n    },\n  };\n\n  // Parse the data string to find functions vs values\n  const tempData = new Function(`return (${dataStr})`)();\n\n  // First pass: create signals for non-functions\n  for (const [key, value] of Object.entries(tempData)) {\n    if (typeof value !== 'function') {\n      signals[key] = new State(value);\n    }\n  }\n\n  // Capture signal keys at this point (before computeds are added)\n  const signalKeys = Object.keys(signals);\n\n  // Helper to build evaluation code - uses only signal keys (not computeds)\n  // to avoid circular dependencies\n  const buildEvalCode = (bodyExpr: string): string => {\n    const getterCode = signalKeys.map(k => `get ${k}() { return s.get('${k}'); }`).join(',');\n    const setterCode = signalKeys.map(k => `set ${k}(v) { s.set('${k}', v); }`).join(',');\n    return `with({${getterCode}${setterCode ? ',' + setterCode : ''}}){return(${bodyExpr})}`;\n  };\n\n  // Second pass: create computeds for functions\n  for (const [key, value] of Object.entries(tempData)) {\n    if (typeof value === 'function') {\n      const fnStr = (value as () => unknown).toString();\n\n      // Extract the function body\n      let bodyExpr: string;\n\n      if (fnStr.includes('=>')) {\n        // Arrow function\n        const arrowIndex = fnStr.indexOf('=>');\n        bodyExpr = fnStr.slice(arrowIndex + 2).trim();\n        // Remove surrounding braces if present and it's a block\n        if (bodyExpr.startsWith('{') && bodyExpr.endsWith('}')) {\n          bodyExpr = bodyExpr.slice(1, -1).trim();\n          if (!bodyExpr.includes('return')) {\n            bodyExpr = `return (${bodyExpr})`;\n          }\n        }\n      } else {\n        // Regular function - extract body\n        const bodyMatch = fnStr.match(/\\{([\\s\\S]*)\\}/);\n        bodyExpr = bodyMatch ? bodyMatch[1].trim() : 'undefined';\n      }\n\n      // Pre-build the evaluation function once (not on every access)\n      const evalCode = buildEvalCode(bodyExpr);\n      const evalFn = new Function('s', evalCode);\n\n      computeds[key] = new Computed(() => {\n        try {\n          return evalFn(scope);\n        } catch (e) {\n          console.error(`Error in computed \"${key}\":`, e);\n          return undefined;\n        }\n      });\n    }\n  }\n\n  scopes.set(el, scope);\n  return scope;\n}\n\nfunction findScope(el: Element): ComponentScope | undefined {\n  let current: Element | null = el;\n  while (current) {\n    const scope = scopes.get(current);\n    if (scope) return scope;\n    current = current.parentElement;\n  }\n  return undefined;\n}\n\n// Build with-context code for expressions\nfunction buildWithCode(scope: ComponentScope): string {\n  const keys = [...Object.keys(scope.signals), ...Object.keys(scope.computeds)];\n  const g = keys.map(k => `get ${k}(){return s.get('${k}')}`).join(',');\n  const t = Object.keys(scope.signals).map(k => `set ${k}(v){s.set('${k}',v)}`).join(',');\n  return `with({${g}${t ? ',' + t : ''}})`;\n}\n\nfunction evaluateExpression(expr: string, scope: ComponentScope): unknown {\n  try {\n    return new Function('s', `${buildWithCode(scope)}{return(${expr})}`)(scope);\n  } catch (e) {\n    console.error(`Error evaluating: ${expr}`, e);\n    return undefined;\n  }\n}\n\nfunction executeStatement(stmt: string, scope: ComponentScope, event?: Event): void {\n  try {\n    new Function('s', '$event', `${buildWithCode(scope)}{${stmt}}`)(scope, event);\n  } catch (e) {\n    console.error(`Error executing: ${stmt}`, e);\n  }\n}\n\nfunction processTextDirective(el: Element, expr: string, scope: ComponentScope): void {\n  effect(() => {\n    const value = evaluateExpression(expr, scope);\n    el.textContent = String(value ?? '');\n  });\n}\n\nfunction processHtmlDirective(el: Element, expr: string, scope: ComponentScope): void {\n  effect(() => {\n    const value = evaluateExpression(expr, scope);\n    el.innerHTML = String(value ?? '');\n  });\n}\n\nfunction processShowDirective(el: HTMLElement, expr: string, scope: ComponentScope): void {\n  const originalDisplay = el.style.display || '';\n\n  effect(() => {\n    const value = evaluateExpression(expr, scope);\n    el.style.display = value ? originalDisplay : 'none';\n  });\n}\n\nfunction processBindDirective(el: Element, attr: string, expr: string, scope: ComponentScope): void {\n  effect(() => {\n    const value = evaluateExpression(expr, scope);\n\n    if (attr === 'class') {\n      if (typeof value === 'object' && value !== null) {\n        // Object syntax: { 'class-name': boolean }\n        for (const [className, enabled] of Object.entries(value)) {\n          el.classList.toggle(className, Boolean(enabled));\n        }\n      } else {\n        el.setAttribute('class', String(value ?? ''));\n      }\n    } else if (attr === 'style') {\n      if (typeof value === 'object' && value !== null) {\n        // Object syntax: { property: value }\n        for (const [prop, val] of Object.entries(value)) {\n          (el as HTMLElement).style.setProperty(prop, String(val ?? ''));\n        }\n      } else {\n        el.setAttribute('style', String(value ?? ''));\n      }\n    } else if (value === null || value === undefined || value === false) {\n      el.removeAttribute(attr);\n    } else if (value === true) {\n      el.setAttribute(attr, '');\n    } else {\n      el.setAttribute(attr, String(value));\n    }\n  });\n}\n\nfunction processModelDirective(el: Element, expr: string, scope: ComponentScope): void {\n  const input = el as HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement;\n\n  // Two-way binding\n  effect(() => {\n    const value = evaluateExpression(expr, scope);\n    if (input.type === 'checkbox') {\n      (input as HTMLInputElement).checked = Boolean(value);\n    } else if (input.type === 'radio') {\n      (input as HTMLInputElement).checked = input.value === String(value);\n    } else {\n      input.value = String(value ?? '');\n    }\n  });\n\n  const eventType = input.tagName === 'SELECT' || input.type === 'checkbox' || input.type === 'radio'\n    ? 'change'\n    : 'input';\n\n  input.addEventListener(eventType, () => {\n    let newValue: unknown;\n    if (input.type === 'checkbox') {\n      newValue = (input as HTMLInputElement).checked;\n    } else if (input.type === 'number' || input.type === 'range') {\n      newValue = input.valueAsNumber;\n    } else {\n      newValue = input.value;\n    }\n\n    // Set the value directly\n    if (expr in scope.signals) {\n      scope.set(expr, newValue);\n    } else {\n      executeStatement(`${expr} = ${JSON.stringify(newValue)}`, scope);\n    }\n  });\n}\n\nfunction processEventDirective(el: Element, eventName: string, handler: string, scope: ComponentScope): void {\n  // Parse modifiers\n  const parts = eventName.split('.');\n  const event = parts[0];\n  const modifiers = new Set(parts.slice(1));\n\n  el.addEventListener(event, (e) => {\n    if (modifiers.has('prevent')) e.preventDefault();\n    if (modifiers.has('stop')) e.stopPropagation();\n    if (modifiers.has('self') && e.target !== el) return;\n\n    // Handle key modifiers for keyboard events\n    if (e instanceof KeyboardEvent) {\n      if (modifiers.has('enter') && e.key !== 'Enter') return;\n      if (modifiers.has('escape') && e.key !== 'Escape') return;\n      if (modifiers.has('space') && e.key !== ' ') return;\n      if (modifiers.has('tab') && e.key !== 'Tab') return;\n    }\n\n    executeStatement(handler, scope, e);\n  }, { once: modifiers.has('once'), capture: modifiers.has('capture') });\n}\n\nfunction processElement(el: Element, scope: ComponentScope): void {\n  // Get all attributes to process\n  const attributes = Array.from(el.attributes);\n\n  for (const attr of attributes) {\n    const name = attr.name;\n    const value = attr.value;\n\n    if (name === DIRECTIVES.TEXT) {\n      processTextDirective(el, value, scope);\n    } else if (name === DIRECTIVES.HTML) {\n      processHtmlDirective(el, value, scope);\n    } else if (name === DIRECTIVES.SHOW) {\n      processShowDirective(el as HTMLElement, value, scope);\n    } else if (name === DIRECTIVES.MODEL) {\n      processModelDirective(el, value, scope);\n    } else if (name.startsWith(DIRECTIVES.BIND + ':') || name.startsWith(':')) {\n      // x-bind:attr or :attr shorthand\n      const bindAttr = name.startsWith(':') ? name.slice(1) : name.slice(DIRECTIVES.BIND.length + 1);\n      processBindDirective(el, bindAttr, value, scope);\n    } else if (name.startsWith(DIRECTIVES.ON + ':') || name.startsWith('@')) {\n      // x-on:event or @event shorthand\n      const eventName = name.startsWith('@') ? name.slice(1) : name.slice(DIRECTIVES.ON.length + 1);\n      processEventDirective(el, eventName, value, scope);\n    }\n  }\n}\n\nfunction initializeComponent(root: Element): void {\n  const dataAttr = root.getAttribute(DIRECTIVES.DATA);\n  if (!dataAttr) return;\n\n  let scope: ComponentScope;\n  try {\n    scope = createScopeFromString(root, dataAttr);\n  } catch (e) {\n    console.error(`Error parsing x-data: ${dataAttr}`, e);\n    return;\n  }\n\n  // Process the root element\n  processElement(root, scope);\n\n  // Process all child elements\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  let node: Element | null;\n\n  while ((node = walker.nextNode() as Element | null)) {\n    // Skip nested x-data components - they'll be initialized separately\n    if (node.hasAttribute(DIRECTIVES.DATA)) {\n      continue;\n    }\n    processElement(node, scope);\n  }\n}\n\nfunction init(root: Element | Document = document): void {\n  const components = root.querySelectorAll(`[${DIRECTIVES.DATA}]`);\n\n  for (const component of components) {\n    initializeComponent(component);\n  }\n}\n\n// Auto-initialize when DOM is ready\nif (typeof document !== 'undefined') {\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', () => init());\n  } else {\n    // DOM already loaded, initialize on next tick\n    queueMicrotask(() => init());\n  }\n}\n\n// Export for manual initialization\nexport const SignalHTML = {\n  init,\n  State,\n  Computed,\n  effect,\n  untrack,\n  version: '0.1.0',\n};\n\n// Also export as default\nexport default SignalHTML;\n\n// Make available globally\nif (typeof window !== 'undefined') {\n  (window as unknown as Record<string, unknown>).SignalHTML = SignalHTML;\n}\n", "/**\n * TC39 Signals - Minimal Implementation\n */\n\ntype Version = number;\n\nlet activeConsumer: ReactiveNode | null = null;\nlet inNotificationPhase = false;\nlet epoch: Version = 1;\n\ninterface ReactiveNode {\n  version: Version;\n  lastCleanEpoch: Version;\n  dirty: boolean;\n  producerNode: ReactiveNode[] | undefined;\n  producerLastReadVersion: Version[] | undefined;\n  producerIndexOfThis: number[] | undefined;\n  nextProducerIndex: number;\n  liveConsumerNode: ReactiveNode[] | undefined;\n  liveConsumerIndexOfThis: number[] | undefined;\n  consumerAllowSignalWrites: boolean;\n  consumerIsAlwaysLive: boolean;\n  producerMustRecompute(node: unknown): boolean;\n  producerRecomputeValue(node: unknown): void;\n  consumerMarkedDirty(): void;\n  watched?(): void;\n  unwatched?(): void;\n  wrapper?: unknown;\n  equal?(a: unknown, b: unknown): boolean;\n  value?: unknown;\n  computation?: () => unknown;\n  error?: unknown;\n}\n\nconst REACTIVE_NODE: ReactiveNode = {\n  version: 0,\n  lastCleanEpoch: 0,\n  dirty: false,\n  producerNode: undefined,\n  producerLastReadVersion: undefined,\n  producerIndexOfThis: undefined,\n  nextProducerIndex: 0,\n  liveConsumerNode: undefined,\n  liveConsumerIndexOfThis: undefined,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {},\n  consumerMarkedDirty: () => {},\n};\n\nfunction setActiveConsumer(consumer: ReactiveNode | null): ReactiveNode | null {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\n\nexport function isInNotificationPhase(): boolean {\n  return inNotificationPhase;\n}\n\nfunction assertConsumerNode(node: ReactiveNode): void {\n  node.producerNode ??= [];\n  node.producerIndexOfThis ??= [];\n  node.producerLastReadVersion ??= [];\n}\n\nfunction assertProducerNode(node: ReactiveNode): void {\n  node.liveConsumerNode ??= [];\n  node.liveConsumerIndexOfThis ??= [];\n}\n\nfunction consumerIsLive(node: ReactiveNode): boolean {\n  return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;\n}\n\nfunction producerAddLiveConsumer(node: ReactiveNode, consumer: ReactiveNode, indexOfThis: number): number {\n  assertProducerNode(node);\n  assertConsumerNode(node);\n  if (node.liveConsumerNode!.length === 0) {\n    node.watched?.call(node.wrapper);\n    for (let i = 0; i < node.producerNode!.length; i++) {\n      node.producerIndexOfThis![i] = producerAddLiveConsumer(node.producerNode![i], node, i);\n    }\n  }\n  node.liveConsumerIndexOfThis!.push(indexOfThis);\n  return node.liveConsumerNode!.push(consumer) - 1;\n}\n\nfunction producerRemoveLiveConsumerAtIndex(node: ReactiveNode, idx: number): void {\n  assertProducerNode(node);\n  assertConsumerNode(node);\n\n  if (node.liveConsumerNode!.length === 1) {\n    node.unwatched?.call(node.wrapper);\n    for (let i = 0; i < node.producerNode!.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode![i], node.producerIndexOfThis![i]);\n    }\n  }\n\n  const lastIdx = node.liveConsumerNode!.length - 1;\n  node.liveConsumerNode![idx] = node.liveConsumerNode![lastIdx];\n  node.liveConsumerIndexOfThis![idx] = node.liveConsumerIndexOfThis![lastIdx];\n  node.liveConsumerNode!.length--;\n  node.liveConsumerIndexOfThis!.length--;\n\n  if (idx < node.liveConsumerNode!.length) {\n    const idxProducer = node.liveConsumerIndexOfThis![idx];\n    const consumer = node.liveConsumerNode![idx];\n    assertConsumerNode(consumer);\n    consumer.producerIndexOfThis![idxProducer] = idx;\n  }\n}\n\nfunction producerAccessed(node: ReactiveNode): void {\n  if (inNotificationPhase) {\n    throw new Error('Read in notify');\n  }\n\n  if (activeConsumer === null) return;\n\n  const idx = activeConsumer.nextProducerIndex++;\n  assertConsumerNode(activeConsumer);\n\n  if (idx < activeConsumer.producerNode!.length && activeConsumer.producerNode![idx] !== node) {\n    if (consumerIsLive(activeConsumer)) {\n      const staleProducer = activeConsumer.producerNode![idx];\n      producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis![idx]);\n    }\n  }\n\n  if (activeConsumer.producerNode![idx] !== node) {\n    activeConsumer.producerNode![idx] = node;\n    activeConsumer.producerIndexOfThis![idx] = consumerIsLive(activeConsumer)\n      ? producerAddLiveConsumer(node, activeConsumer, idx)\n      : 0;\n  }\n  activeConsumer.producerLastReadVersion![idx] = node.version;\n}\n\nfunction producerIncrementEpoch(): void {\n  epoch++;\n}\n\nfunction consumerPollProducersForChange(node: ReactiveNode): boolean {\n  assertConsumerNode(node);\n  for (let i = 0; i < node.producerNode!.length; i++) {\n    const producer = node.producerNode![i];\n    const seenVersion = node.producerLastReadVersion![i];\n    if (seenVersion !== producer.version) return true;\n    producerUpdateValueVersion(producer);\n    if (seenVersion !== producer.version) return true;\n  }\n  return false;\n}\n\nfunction producerUpdateValueVersion(node: ReactiveNode): void {\n  if (!node.dirty && node.lastCleanEpoch === epoch) return;\n\n  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n    node.dirty = false;\n    node.lastCleanEpoch = epoch;\n    return;\n  }\n\n  node.producerRecomputeValue(node);\n  node.dirty = false;\n  node.lastCleanEpoch = epoch;\n}\n\nfunction producerNotifyConsumers(node: ReactiveNode): void {\n  if (node.liveConsumerNode === undefined) return;\n\n  const prev = inNotificationPhase;\n  inNotificationPhase = true;\n  try {\n    for (const consumer of node.liveConsumerNode) {\n      if (!consumer.dirty) {\n        consumerMarkDirty(consumer);\n      }\n    }\n  } finally {\n    inNotificationPhase = prev;\n  }\n}\n\nfunction consumerMarkDirty(node: ReactiveNode): void {\n  node.dirty = true;\n  producerNotifyConsumers(node);\n  node.consumerMarkedDirty?.call(node.wrapper ?? node);\n}\n\nfunction consumerBeforeComputation(node: ReactiveNode | null): ReactiveNode | null {\n  node && (node.nextProducerIndex = 0);\n  return setActiveConsumer(node);\n}\n\nfunction consumerAfterComputation(node: ReactiveNode | null, prevConsumer: ReactiveNode | null): void {\n  setActiveConsumer(prevConsumer);\n  if (!node || node.producerNode === undefined) return;\n\n  if (consumerIsLive(node)) {\n    for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis![i]);\n    }\n  }\n\n  while (node.producerNode.length > node.nextProducerIndex) {\n    node.producerNode.pop();\n    node.producerLastReadVersion!.pop();\n    node.producerIndexOfThis!.pop();\n  }\n}\n\nfunction defaultEquals<T>(a: T, b: T): boolean {\n  return Object.is(a, b);\n}\n\nconst NODE = Symbol('node');\n\n// Sentinel values for computed\nconst UNSET = Symbol('UNSET');\nconst COMPUTING = Symbol('COMPUTING');\nconst ERRORED = Symbol('ERRORED');\n\nexport interface SignalOptions<T> {\n  equals?: (a: T, b: T) => boolean;\n}\n\nexport class State<T> {\n  readonly [NODE]: ReactiveNode;\n\n  constructor(initialValue: T, options: SignalOptions<T> = {}) {\n    const node: ReactiveNode = Object.create(REACTIVE_NODE);\n    node.value = initialValue;\n    node.equal = options.equals ?? defaultEquals;\n    node.version = 0;\n    node.wrapper = this;\n    this[NODE] = node;\n  }\n\n  get(): T {\n    producerAccessed(this[NODE]);\n    return this[NODE].value as T;\n  }\n\n  set(newValue: T): void {\n    if (isInNotificationPhase()) {\n      throw new Error('Write in notify');\n    }\n    const node = this[NODE];\n    if (!node.equal!(node.value, newValue)) {\n      node.value = newValue;\n      node.version++;\n      producerIncrementEpoch();\n      producerNotifyConsumers(node);\n    }\n  }\n}\n\nexport class Computed<T> {\n  readonly [NODE]: ReactiveNode;\n\n  constructor(computation: () => T, options: SignalOptions<T> = {}) {\n    const node: ReactiveNode = Object.create(REACTIVE_NODE);\n    node.computation = computation;\n    node.value = UNSET;\n    node.dirty = true;\n    node.error = null;\n    node.equal = options.equals ?? defaultEquals;\n    node.consumerAllowSignalWrites = true;\n    node.wrapper = this;\n\n    node.producerMustRecompute = (n: ReactiveNode) => n.value === UNSET || n.value === COMPUTING;\n\n    node.producerRecomputeValue = (n: ReactiveNode) => {\n      if (n.value === COMPUTING) {\n        throw new Error('Cycle');\n      }\n\n      const oldValue = n.value;\n      n.value = COMPUTING;\n\n      const prevConsumer = consumerBeforeComputation(n);\n      let newValue: unknown;\n      let wasEqual = false;\n      try {\n        newValue = n.computation!();\n        const oldOk = oldValue !== UNSET && oldValue !== ERRORED;\n        wasEqual = oldOk && n.equal!(oldValue, newValue);\n      } catch (err) {\n        newValue = ERRORED;\n        n.error = err;\n      } finally {\n        consumerAfterComputation(n, prevConsumer);\n      }\n\n      if (wasEqual) {\n        n.value = oldValue;\n        return;\n      }\n\n      n.value = newValue;\n      n.version++;\n    };\n\n    this[NODE] = node;\n  }\n\n  get(): T {\n    const node = this[NODE];\n    producerUpdateValueVersion(node);\n    producerAccessed(node);\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n    return node.value as T;\n  }\n}\n\nexport class Watcher {\n  readonly [NODE]: ReactiveNode;\n  #signals: Array<State<unknown> | Computed<unknown>> = [];\n\n  constructor(notify: () => void) {\n    const node: ReactiveNode = Object.create(REACTIVE_NODE);\n    node.wrapper = this;\n    node.consumerMarkedDirty = notify;\n    node.consumerIsAlwaysLive = true;\n    node.consumerAllowSignalWrites = false;\n    node.producerNode = [];\n    this[NODE] = node;\n  }\n\n  watch(...signals: Array<State<unknown> | Computed<unknown>>): void {\n    const node = this[NODE];\n    node.dirty = false;\n    const prev = setActiveConsumer(node);\n    for (const signal of signals) {\n      producerAccessed(signal[NODE]);\n      if (!this.#signals.includes(signal)) {\n        this.#signals.push(signal);\n      }\n    }\n    setActiveConsumer(prev);\n  }\n\n  unwatch(...signals: Array<State<unknown> | Computed<unknown>>): void {\n    const node = this[NODE];\n    assertConsumerNode(node);\n\n    for (let i = node.producerNode!.length - 1; i >= 0; i--) {\n      const signalNode = node.producerNode![i];\n      if (signals.some(s => s[NODE] === signalNode)) {\n        producerRemoveLiveConsumerAtIndex(signalNode, node.producerIndexOfThis![i]);\n\n        const lastIdx = node.producerNode!.length - 1;\n        node.producerNode![i] = node.producerNode![lastIdx];\n        node.producerIndexOfThis![i] = node.producerIndexOfThis![lastIdx];\n\n        node.producerNode!.length--;\n        node.producerIndexOfThis!.length--;\n\n        if (i < node.producerNode!.length) {\n          const idxConsumer = node.producerIndexOfThis![i];\n          const producer = node.producerNode![i];\n          assertProducerNode(producer);\n          producer.liveConsumerIndexOfThis![idxConsumer] = i;\n        }\n      }\n    }\n\n    this.#signals = this.#signals.filter(s => !signals.includes(s));\n  }\n\n  getPending(): Array<Computed<unknown>> {\n    const node = this[NODE];\n    return (node.producerNode ?? [])\n      .filter(n => n.dirty && n.computation !== undefined)\n      .map(n => n.wrapper as Computed<unknown>);\n  }\n}\n\nexport function untrack<T>(fn: () => T): T {\n  const prev = setActiveConsumer(null);\n  try {\n    return fn();\n  } finally {\n    setActiveConsumer(prev);\n  }\n}\n", "/**\n * Effect System - Reactive side effects built on TC39 Signals\n */\n\nimport { Computed, Watcher } from './signals';\n\nlet needsEnqueue = true;\nlet pendingEffects: Set<Computed<void>> = new Set();\n\nconst watcher = new Watcher(() => {\n  if (needsEnqueue) {\n    needsEnqueue = false;\n    queueMicrotask(processPending);\n  }\n});\n\nfunction processPending(): void {\n  needsEnqueue = true;\n\n  for (const computed of watcher.getPending()) {\n    computed.get();\n  }\n\n  watcher.watch();\n}\n\nexport type CleanupFn = () => void;\nexport type EffectFn = () => CleanupFn | void;\n\nexport function effect(callback: EffectFn): () => void {\n  let cleanup: CleanupFn | void;\n\n  const computed = new Computed<void>(() => {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    }\n    cleanup = callback();\n  });\n\n  watcher.watch(computed);\n  computed.get(); // Run immediately\n\n  return () => {\n    watcher.unwatch(computed);\n    if (typeof cleanup === 'function') {\n      cleanup();\n    }\n  };\n}\n\nexport function batch(fn: () => void): void {\n  // Simple batch - just run the function\n  // The effect system already batches via microtask\n  fn();\n}\n"],
  "mappings": "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",
  "names": []
}
